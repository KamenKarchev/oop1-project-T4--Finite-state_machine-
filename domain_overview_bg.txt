1. Преглед на предметната област (½–1 стр.)

Проектът реализира система за работа с крайни автомати (finite state machines), като фокусът е върху много-ребрени
ориентирани графи (multiedge directed graphs), ε-преходи и конструиране на автомати от регулярни изрази. Управлението
на системата става чрез конзолен интерфейс (CLI) с команди, а състоянието (регистър от автомати) може да се пази/зарежда
от XML файлове.


1.1. Основни дефиниции, концепции и алгоритми, които ще бъдат използвани

Краен автомат (FA)
- Краен автомат е математически модел за разпознаване на езици над азбука Σ (сигма).
- В този проект автоматът е описван като:
  M = { S, Σ, T, I, A }
  където:
  - S: множество от състояния (states)
  - Σ: азбука (alphabet), множество от допустими символи
  - T: преходи (transitions)
  - I: множество от начални състояния (start states)
  - A: множество от крайни/приемащи състояния (accept/final states)

Много-ребрен ориентиран граф (Multiedge Directed Graph)
- Състоянията S и преходите T се представят чрез графова структура:
  - Възел (Node) представлява състояние.
  - Ребро (Edge) представлява преход от “from” към “to” с етикет (label).
- “Multiedge” означава, че между две състояния могат да съществуват повече от един преход (възможно и с различни етикети,
  и с еднакви етикети, ако моделът го допуска).

Етикет на преход и ε-преход
- Етикетът е символ от азбуката Σ.
- ε-преход (epsilon transition) е преход, който не “консумира” символ от входната дума. В кода ε се представя като
  label == null (или като празно съдържание в XML при сериализация).

NFA vs DFA и детерминизъм
- DFA (детерминистичен автомат) има най-много един преход за даден символ от дадено състояние.
- NFA (недетерминистичен автомат) позволява множество преходи със същия символ, както и ε-преходи.
- В проекта се поддържа NFA модел с ε-преходи и функция за проверка дали автоматът е детерминистичен според правилата.

Разпознаване на дума (recognition / membership)
- Задачата “recognize” проверява дали дадена дума принадлежи на езика L(M), разпознаван от автомата.
- За NFA с ε-преходи това се прави чрез:
  - ε-closure (епсилон-обвивка): множество от състояния, достижими само чрез ε-преходи.
  - Симулиране на NFA: започва се от ε-closure на I, за всеки входен символ се преминава към всички следващи състояния
    по ребра със съответния символ, след което отново се взема ε-closure.
  - Ако след обработка на думата текущото множество от състояния има пресечна точка с A → думата се приема.

Проверка за празен език (emptiness)
- “Празен език” означава, че няма нито една дума, която автоматът да приема.
- Типичен алгоритъм: достижимост от I (включително ε-преходи) и проверка дали се достига поне едно A. Ако не се достига
  нито едно приемащо състояние, езикът е празен.

Операции върху автомати чрез регулярни изрази (regex)
- В проекта се използва регулярна граматика (с експлицитна конкатенация чрез “.” и обединение чрез “+”).
- Парсерът строи ε-NFA от regex (в духа на Thompson construction):
  - За символ a ∈ Σ: строи се минимален автомат с един преход, който приема “a”.
  - За обединение (r1 + r2): нов старт/край и ε-връзки към компонентите.
  - За конкатенация (r1 . r2): ε-връзки от крайни на r1 към стартови на r2.
  - За затваряния (Kleene star / положителна затвореност): добавят се ε-цикли и ε-връзки според оператора.
- В текущата архитектура операции като union/concat могат да се изпълняват чрез композиция на regex-ите и повторен parse.

CLI (Command-driven) архитектура
- CLI слой: въвежда се ред, парсира се в команда + аргументи, валидират се, изпълнява се съответната операция.
- Използвани концепции/шаблони:
  - Command: обект, който представлява изпълнима команда.
  - Strategy: операцията (какво прави командата) е отделена като стратегия.
  - Abstract Factory: конструиране на конкретни команди според “token” (име) и арност (брой аргументи).

XML persistence
- Регистърът от автомати може да се записва и зарежда от XML.
- Машина се пази в XML с атрибути id и reg (оригинален regex), както и секции за I, A и графа:
  - <i> съдържа началните състояния (node name).
  - <a> съдържа крайни състояния.
  - <g> съдържа всички възли; ребрата са вложени вътре в source възела като:
    <node name="q1">
      <edge from="q1" to="q2">a</edge>
      <edge from="q1" to="q3"></edge>   (ε)
    </node>


1.2. Дефиниране на проблеми и сложност на поставената задача

Основни проблеми за решаване
- Моделиране на автомат като граф: коректно представяне на S и T, включително много-ребреност.
- Поддръжка на ε-преходи: коректна ε-closure и симулация при разпознаване.
- Валидиране спрямо Σ: забрана на преходи със символ извън азбуката; отделяне на ε от Σ.
- Управление на множество автомати в сесия: идентификатори (id), регистър, операции между автомати.
- Парсване на regex: правилен синтаксис, приоритети, скоби, оператори + и . и затваряния; генериране на коректен ε-NFA.
- Съхранение и възстановяване на състояние чрез XML: сериализация/десериализация на граф, старт/край, regex метаданни.
- Надеждна CLI система: различаване на команди по арност (пример: два варианта на “save”), ясни грешки и съобщения.

Сложност (ориентировъчна, за типична реализация)
- Разпознаване на дума с ε-NFA:
  - Нека |w| е дължината на думата, |S| брой състояния, |T| брой ребра.
  - На всяка стъпка се поддържа множество от текущи състояния; ε-closure обхожда ε-ребра.
  - При наивна реализация: O(|w| * (|S| + |T|)) в най-лошия случай, обикновено с BFS/DFS по ε-ребра.
- Проверка за празен език:
  - BFS/DFS от I (включително ε-ребра): O(|S| + |T|).
- Проверка за детерминизъм:
  - За всеки възел: групиране/проверка на изходящи ребра по символ (без ε): O(|T|) общо, при използване на хеширане.
- Парсване на regex:
  - Типично линейно спрямо дължината на regex: O(n), при коректна рекурсивна/шънтинг-ярд обработка.
  - Размерът на построения ε-NFA е O(n) състояния/преходи (Thompson construction дава линейно увеличение).

Сложност на интеграцията
- Проектът комбинира няколко различни “слоя” (CLI, домейн, persistence), което изисква ясни граници и интерфейси.
- Грешки/изключения трябва да се пренасят през слоевете и да се представят разбираемо към потребителя.


1.3. Подходи, методи (евентуално модели и стандарти) за решаване на поставените проблемите

Обектно-ориентиран модел и разделение на отговорности
- Графов слой:
  - Интерфейси `graph.base.Node`, `graph.base.Edge`, `graph.base.Graph` дефинират общото поведение.
  - Конкретна реализация `graph.mdg.*` реализира “multiedge directed graph”.
- Машинен слой:
  - `machine.MultiedgeFinateLogicMachine` реализира автоматната семантика (Σ, I, A, операции), като използва графа за S и T.
  - `machine.MachineRegistry` държи множество машини в паметта по ID.
  - `machine.MachineFacade` дава “високо ниво” операции и форматиране за CLI.
- CLI слой:
  - `cli.command.CommandHandler` приема редове, резолва токени, създава командни обекти чрез фабрики и ги изпълнява.
  - Командите са разделени по домейн (base/file/machine) и са независими от конкретното парсване на реда.
- Persistence слой:
  - `io.MachineXmlStore` реализира XML сериализация/десериализация.
  - `io.RegistryFileSession` пази “текущ файл” (open/save/saveas/close семантика).

Шаблони за проектиране
- Facade:
  - Една точка за достъп за операции върху автомати (MachineFacade), удобна за CLI и за бъдещи разширения.
- Abstract Factory:
  - По един factory за всяка команда. Позволява лесно добавяне на нови команди без промени в основния handler.
- Strategy:
  - Операциите на командите се реализират като стратегия (Operation), което позволява изчистване на зависимостите и
    ясни unit-подобни тестове на операции.
- Delegation:
  - Graph интерфейсът делегира edge-операциите към source node, за да се запази моделът “Graph е колекция от Node, Node е
    колекция от Edge”.

Стандарти/формати
- XML формат (custom, но структуриран): отделни секции за I, A, G и вложени edge елементи под node.
- Използване на стандартните Java XML библиотеки (DOM) за съвместимост и независимост от външни зависимости.

Обработка на грешки чрез изключения
- Домейн-специфични изключения: `exceptions.cli.*`, `exceptions.graph.*`, `exceptions.machine.*`, `exceptions.regex.*`,
  `exceptions.facade.*`.
- Цел: вместо “boolean” за успех/неуспех се дава ясна причина за проблема (липсващ възел, невалиден символ и т.н.).


1.4. Потребителски (функционални) изисквания и качествени (нефункционални) изисквания

Функционални изисквания (какво може да прави потребителят)
- Управление на сесия и помощ:
  - help: показва наличните команди и употреба.
  - exit: изход от приложението.
- Работа с регистър/файлове (XML persistence):
  - open <file>: зарежда регистър от XML файл и го прави “текущ”.
  - save: записва текущия регистър в последно отворения файл (ако има такъв).
  - saveas <file>: записва текущия регистър в нов файл и го прави “текущ”.
  - close: “затваря” текущия файл (нулира пътя), без да трие данни от паметта.
  - save <id> <file>: записва единична машина по ID като отделен XML файл.
- Операции върху автомати (в паметта, по ID):
  - list: изброява наличните ID-та в регистъра.
  - reg <regex>: създава нов автомат от регулярния израз, регистрира го и извежда неговото ID (и/или regex).
  - print <id>: печата представяне на автомата (състояния, преходи, I, A).
  - empty <id>: проверява дали езикът на автомата е празен.
  - deterministic <id>: проверява дали автоматът е детерминистичен.
  - recognize <id> <word>: проверява дали автоматът приема думата (поддържа и празна дума чрез "").
  - union <id1> <id2>: създава нов автомат, който приема обединението на езиците (чрез regex-композиция и parse).
  - concat <id1> <id2>: създава нов автомат за конкатенация (чрез regex-композиция с “.”).
  - un <id>: положителна затвореност (1 или повече повторения), реализира се чрез regex-композиция и parse.

Права, роли, статуси
- Роли: един потребител (локален CLI). Няма автентикация, роли или конкурентни потребители в рамките на заданието.
- Статуси/състояния на системата:
  - In-memory registry: текущ набор от автомати в RAM.
  - Current file (optional): път до отворен XML файл за save/close семантика.
  - Machine identity: всяка машина има уникално ID в рамките на сесията/заредения регистър.

Качествени (нефункционални) изисквания
- Коректност:
  - Операциите recognize/empty/deterministic трябва да са коректни при ε-преходи и много-ребреност.
  - Азбуката Σ трябва да се прилага като ограничение (освен ε).
- Поддръжка и разширяемост:
  - Добавянето на нови CLI команди да става чрез нов клас команда + нов factory, без промени по handler-а.
  - Слоевете да са с ниска свързаност (CLI да не “знае” детайли за XML или за вътрешни структури).
- Надеждност:
  - При грешни входни данни да се показват ясни съобщения (чрез специфични изключения), без срив на приложението.
  - При липса на “open file” команда save трябва да дава смислена грешка.
- Производителност:
  - Операциите за разпознаване и достижимост да са линейни спрямо размера на графа и входа (доколкото е възможно).
  - Използване на хеш-структури за бързи проверки (напр. множество от ребра във възела).
- Преносимост:
  - Проектът е чист Java и използва стандартни библиотеки; трябва да работи на стандартна JVM (Windows/Linux/macOS).
- Документация:
  - Кодът е документиран с Javadoc (на български) за основните пакети, класове и по-сложни методи.

