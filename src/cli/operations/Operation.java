package cli.operations;

import java.util.List;

/**
 * <h2>Операция на команда (Strategy)</h2>
 *
 * <p>
 * {@code Operation} е функционален интерфейс, който описва „реалната работа“ на една CLI команда.
 * Той е отделен от обекта {@link cli.command.Command}, за да може:
 * </p>
 *
 * <ul>
 *   <li>командата да бъде тънък wrapper (token + arity + operation);</li>
 *   <li>операцията да се имплементира кратко като ламбда израз;</li>
 *   <li>валидиране на арност да е централизирано в базовия клас на командите.</li>
 * </ul>
 *
 * <h3>Аргументи</h3>
 *
 * <p>
 * Аргументите са вече токенизирани (без името на командата) и са в реда от CLI.
 * За команди без параметри обикновено се подава празен списък.
 * </p>
 *
 * <h3>Грешки</h3>
 *
 * <p>
 * Методът е деклариран с {@code throws Exception}, защото операциите могат да хвърлят:
 * </p>
 *
 * <ul>
 *   <li>CLI изключения (невалидни аргументи);</li>
 *   <li>домейн изключения (липсваща машина, невалиден regex и т.н.);</li>
 *   <li>I/O изключения при работа с файлове.</li>
 * </ul>
 */
@FunctionalInterface
public interface Operation {
    /**
     * Изпълнява операцията над параметрите.
     *
     * @param args параметри от CLI (без името на командата)
     * @throws Exception при грешка във входа или домейн/ I/O проблем
     */
    void execute(List<String> args) throws Exception;
}
